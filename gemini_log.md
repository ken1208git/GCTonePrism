# GCTonePrism 開発ログ with Gemini

**目的:** このドキュメントは、Geminiとの対話を通じて`GCTonePrism`を開発する過程を、**可能な限り詳細に記録する**ためのものです。コードの変更だけでなく、設計に関する議論、発生した問題とその解決策、そして最終的な意思決定に至るまでの思考プロセスをすべて保存し、将来の参照性を最大化することを目的とします。



## 2025-06-30

### 1. プロジェクトの引き継ぎと方針確認

- **発端:** ユーザーがWeb UI版のGeminiで進めていたプロジェクト`GCTonePrism`の引き継ぎを、CLI版のGeminiに依頼。Web UIではコンテキスト長の制限により、多くの情報を一度に扱えない問題があった。
- **命名規則に関する議論:**
    - **ユーザーの疑問:** 以前のWeb UIでの対話で「広く引用するファイルはファイル名を大文字にする」という助言を受けたが、直感に反する感覚がある、との質問。
    - **Geminiからの説明:** 一般的なGodot/GDScriptの慣習を提示。
        - `PascalCase` (大文字始まり): クラス名、シングルトン名 (例: `Global`, `PlayerController`)。これらは「設計図」や「概念」を表す。
        - `snake_case` (小文字始まり): ファイル名、変数名、関数名 (例: `player.gd`, `player_speed`, `_on_jump()`)。これらは「具体的な実体」や「データ」、「処理」を表す。
        - `SCREAMING_SNAKE_CASE`: 定数 (例: `MAX_SPEED`)。
    - **意思決定:** ユーザーはコミュニティの標準である公式ルールに則ることを決定。既存コードがこのルールに準拠しているか確認し、もし逸脱していれば修正する方針で合意。
- **既存コードの確認:**
    - `Global.gd`, `debug_monitor.gd`, `menu.gd` などの主要スクリプトを調査した結果、**すべてのコードが既に標準的な命名規則に準拠している**ことが判明。リファクタリングは不要と結論。

### 2. ファイルI/O問題の特定と解決

- **事象の発生:** `README.md`の改善版を `write_file` や `replace` ツールで書き込もうとしたところ、複数回にわたり `EBADF: bad file descriptor` や `ENOENT: no such file or directory` といったエラーで失敗。
- **原因の切り分け:**
    - **テスト:** 問題の切り分けのため、`test_write.txt`の新規作成を試みるも、同様に`ENOENT`エラーで失敗。これにより、`README.md`固有の問題ではなく、ファイル書き込み全般の問題であると特定。
    - **ユーザーからの情報提供:** ユーザーが`ENOENT`エラーについてWebで検索し、Linux環境での32/64bitアーキテクチャ不一致の可能性を提示。
    - **Geminiによる分析:** 提示された記事の内容を分析。現在のWindows環境でのテキストファイル書き込みという状況とは異なるため、アーキテクチャ不一致の可能性は低いと判断。
    - **根本原因の推定:** 最も可能性の高い原因として、Windowsのセキュリティ機能**「コントロールされたフォルダーアクセス」**が、Gemini CLIによるドキュメントフォルダへの書き込みをブロックしている、あるいはOneDriveの同期プロセスがファイルロックをかけている可能性を提示。
- **解決:** ユーザーが自身のPCで**「コントロールされたフォルダーアクセス」をオフ**にしたところ、`README.md`の書き込みに成功。問題の根本原因が同機能であったことが確定した。

### 3. `README.md`の改善

- **ユーザーの要望:** Markdownの記法（フォントサイズ変更など）が分からないため、`README.md`を自動で見やすくしてほしい、との依頼。
- **Geminiの提案と実行:**
    - Markdownでは直接のフォントサイズ変更はせず、見出し・リスト・コードブロック等の構造化で見やすくすることを説明。
    - 構成の明確化、コードブロックの適用、絵文字の活用、開発者向け「Getting Started」セクションの追加などを含む改善版を提案。
    - ファイル書き込み問題の解決後、改善版の内容で`README.md`を正常に上書き更新した。

### 4. データ構造の設計：「ハイブリッド案」の採択

- **発端:** `game_info.json`のサンプル作成を提案したところ、ユーザーから設計に関する鋭い質問。
- **論点1：キーマッピングの方式**
    - **ユーザーの構想:** ゲームごとにマッパーexeを用意するのではなく、単一の管轄exeが、JSONからキーマップデータを読み取って振る舞う方式は可能か？
    - **Geminiの評価:** 技術的に可能であり、より高度で理想的な設計であると評価。
- **論点2：JSONファイルの配置**
    - **ユーザーの疑問:** 全ゲーム情報を単一ファイルで管理するより、各ゲームフォルダに分散させた方が楽ではないか？ ただし、表示順の管理が問題になる点を懸念。
- **Geminiからのハイブリッド提案:** 両者のメリットを両立する案を提示。
    - **`launcher_config.json` (ルートに配置):**
        - ゲームの表示順序を配列 `games_order` で集中管理。
        - キーマッパー管轄exeのパス `key_mapper_executable` もここで管理。
    - **`game.json` (各ゲームフォルダ内に配置):**
        - 各ゲーム固有の情報（タイトル、説明、画像パスなど）を管理。
        - ユーザー構想のキーマップデータ `key_mapping` もここに含める。
- **意思決定:** この**ハイブリッド案**が、順序管理の容易さと、各ゲーム情報の独立性を両立できる最も優れた方式であるとして、採用を決定。

### 5. 次のステップ

- この開発ログ `gemini_log.md` を作成・保存する。
- 採択されたハイブリッド案に基づき、`launcher_config.json`をプロジェクトルートに作成する。
- ダミーのゲームフォルダと、その中に配置する`game.json`を作成する。

### 6. 環境設定問題：APIキーの認証

- **事象の発生:** 会話モデルがFlashに切り替わり、APIキーの入力を求められる事象が発生。これにより、Gemini CLIとの対話が一時的に中断。
- **原因の特定と解決:**
    - **ユーザーからの情報:** ユーザーがAPIキーを既に所有していることを確認。
    - **Geminiからの説明:** CLIでのAPIキー入力方法（対話形式、環境変数、設定ファイル）について説明。
    - **PowerShellでの永続設定:** ユーザーがPowerShellを使用していることから、`[System.Environment]::SetEnvironmentVariable("YOUR_API_KEY_NAME", "YOUR_ACTUAL_API_KEY_HERE", "User")` コマンドによる環境変数の永続設定方法を提示。
    - **設定の実行と確認:** ユーザーがコマンドを実行し、エラーなく完了したことを確認。PowerShellの再起動により、APIキーが正常に認識され、Gemini CLIが再び動作可能になった。
- **意思決定:** この環境設定に関する問題と解決策は、将来の参照のために開発ログに記録することが重要であると判断し、追記を決定。
