# GCTonePrism 開発ログ with Gemini

**目的:** このドキュメントは、Geminiとの対話を通じて`GCTonePrism`を開発する過程を、**可能な限り詳細に記録する**ためのものです。コードの変更だけでなく、設計に関する議論、発生した問題とその解決策、そして最終的な意思決定に至るまでの思考プロセスをすべて保存し、将来の参照性を最大化することを目的とします。



## 2025-06-30

### 1. プロジェクトの引き継ぎと方針確認

- **発端:** ユーザーがWeb UI版のGeminiで進めていたプロジェクト`GCTonePrism`の引き継ぎを、CLI版のGeminiに依頼。Web UIではコンテキスト長の制限により、多くの情報を一度に扱えない問題があった。
- **命名規則に関する議論:**
    - **ユーザーの疑問:** 以前のWeb UIでの対話で「広く引用するファイルはファイル名を大文字にする」という助言を受けたが、直感に反する感覚がある、との質問。
    - **Geminiからの説明:** 一般的なGodot/GDScriptの慣習を提示。
        - `PascalCase` (大文字始まり): クラス名、シングルトン名 (例: `Global`, `PlayerController`)。これらは「設計図」や「概念」を表す。
        - `snake_case` (小文字始まり): ファイル名、変数名、関数名 (例: `player.gd`, `player_speed`, `_on_jump()`)。これらは「具体的な実体」や「データ」、「処理」を表す。
        - `SCREAMING_SNAKE_CASE`: 定数 (例: `MAX_SPEED`)。
    - **意思決定:** ユーザーはコミュニティの標準である公式ルールに則ることを決定。既存コードがこのルールに準拠しているか確認し、もし逸脱していれば修正する方針で合意。
- **既存コードの確認:**
    - `Global.gd`, `debug_monitor.gd`, `menu.gd` などの主要スクリプトを調査した結果、**すべてのコードが既に標準的な命名規則に準拠している**ことが判明。リファクタリングは不要と結論。

### 2. ファイルI/O問題の特定と解決

- **事象の発生:** `README.md`の改善版を `write_file` や `replace` ツールで書き込もうとしたところ、複数回にわたり `EBADF: bad file descriptor` や `ENOENT: no such file or directory` といったエラーで失敗。
- **原因の切り分け:**
    - **テスト:** 問題の切り分けのため、`test_write.txt`の新規作成を試みるも、同様に`ENOENT`エラーで失敗。これにより、`README.md`固有の問題ではなく、ファイル書き込み全般の問題であると特定。
    - **ユーザーからの情報提供:** ユーザーが`ENOENT`エラーについてWebで検索し、Linux環境での32/64bitアーキテクチャ不一致の可能性を提示。
    - **Geminiによる分析:** 提示された記事の内容を分析。現在のWindows環境でのテキストファイル書き込みという状況とは異なるため、アーキテクチャ不一致の可能性は低いと判断。
    - **根本原因の推定:** 最も可能性の高い原因として、Windowsのセキュリティ機能**「コントロールされたフォルダーアクセス」**が、Gemini CLIによるドキュメントフォルダへの書き込みをブロックしている、あるいはOneDriveの同期プロセスがファイルロックをかけている可能性を提示。
- **解決:** ユーザーが自身のPCで**「コントロールされたフォルダーアクセス」をオフ**にしたところ、`README.md`の書き込みに成功。問題の根本原因が同機能であったことが確定した。

### 3. `README.md`の改善

- **ユーザーの要望:** Markdownの記法（フォントサイズ変更など）が分からないため、`README.md`を自動で見やすくしてほしい、との依頼。
- **Geminiの提案と実行:**
    - Markdownでは直接のフォントサイズ変更はせず、見出し・リスト・コードブロック等の構造化で見やすくすることを説明。
    - 構成の明確化、コードブロックの適用、絵文字の活用、開発者向け「Getting Started」セクションの追加などを含む改善版を提案。
    - ファイル書き込み問題の解決後、改善版の内容で`README.md`を正常に上書き更新した。

### 4. データ構造の設計：「ハイブリッド案」の採択

- **発端:** `game_info.json`のサンプル作成を提案したところ、ユーザーから設計に関する鋭い質問。
- **論点1：キーマッピングの方式**
    - **ユーザーの構想:** ゲームごとにマッパーexeを用意するのではなく、単一の管轄exeが、JSONからキーマップデータを読み取って振る舞う方式は可能か？
    - **Geminiの評価:** 技術的に可能であり、より高度で理想的な設計であると評価。
- **論点2：JSONファイルの配置**
    - **ユーザーの疑問:** 全ゲーム情報を単一ファイルで管理するより、各ゲームフォルダに分散させた方が楽ではないか？ ただし、表示順の管理が問題��なる点を懸念。
- **Geminiからのハイブリッド提案:** 両者のメリットを両立する案を提示。
    - **`launcher_config.json` (ルートに配置):**
        - ゲームの表示順序を配列 `games_order` で集中管理。
        - キーマッパー管轄exeのパス `key_mapper_executable` もここで管理。
    - **`game.json` (各ゲームフォルダ内に配置):**
        - 各ゲーム固有の情報（タイトル、説明、画像パスなど）を管理。
        - ユーザー構想のキーマップデータ `key_mapping` もここに含める。
- **意思決定:** この**ハイブリッド案**が、順序管理の容易さと、各ゲーム情報の独立性を両立できる最も優れた方式であるとして、採用を決定。

### 5. 次のステップ

- この開発ログ `gemini_log.md` を作成・保存する。
- 採択されたハイブリッド案に基づき、`launcher_config.json`をプロジェクトルートに作成する。
- ダミーのゲームフォルダと、その中に配置する`game.json`を作成する。

### 6. 環境設定問題：APIキーの認証

- **事象の発生:** 会話モデルがFlashに切り替わり、APIキーの入力を求められる事象が発生。これにより、Gemini CLIとの対話が一時的に中断。
- **原因の特定と解���:**
    - **ユーザーからの情報:** ユーザーがAPIキーを既に所有していることを確認。
    - **Geminiからの説明:** CLIでのAPIキー入力方法（対話形式、環境変数、設定ファイル）について説明。
    - **PowerShellでの永続設定:** ユーザーがPowerShellを使用していることから、`[System.Environment]::SetEnvironmentVariable("YOUR_API_KEY_NAME", "YOUR_ACTUAL_API_KEY_HERE", "User")` コマンドによる環境変数の永続設定方法を提示。
    - **設定の実行と確認:** ユーザーがコマンドを実行し、エラーなく完了したことを確認。PowerShellの再起動により、APIキーが正常に認識され、Gemini CLIが再び動作可能になった。
- **意思決定:** この環境設定に関する問題と解決策は、将来の参照のために開発ログに記録することが重要であると判断し、追記を決定。

### 7. 開発環境と正式名称の決定

- **開発環境の方針決定:**
    - **課題:** 学校のPCは再起動するとローカルデータが消去されるという特殊な環境。
    - **解決策:** 外部サーバー（実態はネットワーク共有フォルダ）をプライマリな作業場所として利用する方針を固めた。
    - **具体的な運用:** サーバー上にGodotプロジェクトを配置。GitHub Desktop, VS Code, Gemini CLIといった開発ツールは、すべて「ポータブル版」をサーバー上の特定フォルダに置き、そこから直接起動して作業を行う。これにより、学校PCの環境に依存せず、どこからでも同じ環境で開発を継続できる体制を確立した。

- **プロジェクトの正式名称決定:**
    - **議論:** 元の名称「ゲームセンターTONE ランチャーシステム Prism」に、プロジェクトの多機能性を反映させるための議論を実施。
    - **意思決定:** 複数の候補の中から、機能性を的確に表す「**ゲームセンターTONE 統合ランチャーシステム Prism**」を正式名称として採択。
    - **反映:** 決定に基づき、ユーザーが`README.md`のタイトルを即時更新した。

### 8. `GEMINI.md`の改訂：AIの振る舞いに関するルール強化

- **発端:** 開発を進める中で、AI（Gemini）のプロジェクト理解度とコード解説の一貫性をさらに向上させる必要性が浮上。
- **議論と意思決定:** ユーザーからの提案に基づき、AIの振る舞いを規定する`GEMINI.md`の内容を、より具体的かつ強制力のあるルールに改訂することに合意。
- **改訂内容:**
    1.  **起動シ��ケンスの厳格化:**
        - **ルール:** セッション開始時、`README.md`と`gemini_log.md`の読み込み後、**必ずプロジェクト全体のファイル構造を網羅的に把握する**ことを義務付けた。
        - **目的:** プロジェクトの物理的な全体像を初期段階で完全に理解し、より精度の高い応答を生成するため。
    2.  **コード解説ルールの強化:**
        - **ターゲットの明確化:** コードブロック内のコメント（`#`）は、**「プログラミング経験の浅い新入部員」**が読むことを想定し、コードの「意図」を説明するものと定義。
        - **解説形式の絶対化:** コードブロック外の解説では、ユーザー個人に向けた平易な動作説明、バグ修正の詳細な経緯、そして**キーワード分類（[Godotの機能], [あなたが付けた名前], [定義済みのものを再利用]）を必須項目**として徹底することを決定。
- **反映:** 上記の決定に基づき、`GEMINI.md`を即時更新した。これにより、今後の開発におけるAIとの連携プロセスが標準化され、一貫性と正確性が担保されることになった。

### 9. ファイル破損問題の特定と修復

- **事象の発生:** `gemini_log.md`にセクション8を追��した後、ユーザーからファイル内容の不整合と文字化けの指摘を受ける。
- **原因の特定:**
    - **初期分析:** 当初は改行コード（CRLF/LF）の違いによる表示上の問題と推定。
    - **根本原因の判明:** ユーザーからのさらなる指摘により、**ファイル書き込み時の文字コード（エンコーディング）の取り扱いミスによるデータ破損（文字化け）**が根本原因であると特定。AI側のツールが日本語の文字を破壊していた。
- **修復プロセス:**
    - **方針:** ユーザーの提案に基づき、破損した現在のファイルを正として、AIが文脈を読み取りながら手動で修正する方針を採択。
    - **実行:** `gemini_log.md`および、同様に破損していた`GEMINI.md`の内容を精査し、文字化け箇所を修正したバージョンをユーザーが確認。
    - **完了:** ユーザーの承認を得て、修正済みの内容で両ファイルを上書きし、完全に復旧させた。
- **再発防止策:**
    - **意思決定:** 今後のファイル書き込み、特にログ記録において文字化けを再発させないよう、`GEMINI.md`に**「ファイル書き込み時にUTF-8エンコーディングを維持し、文字化けを絶対に起こさないこと」**という厳格なルールを追記。これにより、AIのファイル操作における品質基準を明確化した。

### 10. GitHub CLIの導入とPATHの問題

- **発端:** ユーザーがGitHubのIssuesをCLI上で直接読み込みたいと要望。
- **経緯:**
    - 解決策として、公式の`gh`コマンド（GitHub CLI）を提案。
    - `gh --version`でインストールの有無を確認したところ、未導入であることが判明。
    - `winget install --id GitHub.cli`コマンドを実行し、インストールを実施。
    - 再度`gh --version`を実行するも、コマンドが認識されないエラーが発生。
- **課題と次のステップ:**
    - インストール直後で、現在のターミナルセッションに実行パス（PATH）が反映されていないことが原因と断定。
    - **解決策として、ユーザーが一度Gemini CLIを再起動する必要がある。**
    - **引き継ぎ事項:** 再起動後、まず`gh --version`を実行してインストールを最終確認し、成功すれば次のステップである`gh auth login`によ���GitHubアカウント認証に進む。
